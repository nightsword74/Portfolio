<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Runner - Endless Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Night Mode Variables */
        :root {
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            --text-primary: #000;
            --text-secondary: #fff;
            --border-color: #000;
            --card-bg: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            --shadow-color: rgba(0,0,0,0.4);
            --button-bg: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            --button-hover: linear-gradient(135deg, #00cc00 0%, #00ff00 100%);
        }

        body.night-mode {
            --bg-primary: linear-gradient(135deg, #0f0c29 0%, #302b63 100%);
            --bg-secondary: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --text-primary: #fff;
            --text-secondary: #ccc;
            --border-color: #fff;
            --card-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow-color: rgba(255,255,255,0.2);
            --button-bg: linear-gradient(135deg, #00ffff 0%, #0088cc 100%);
            --button-hover: linear-gradient(135deg, #0088cc 0%, #00ffff 100%);
        }

        body {
            font-family: 'Comic Sans MS', 'Mukta Malar', 'Chalkboard SE', 'Comic Neue', cursive;
            background: var(--bg-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-y: auto;
            opacity: 0;
            animation: morphIn 1s ease-out forwards;
            transition: background 0.5s ease;
        }

        @keyframes morphIn {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(50px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Section Animation */
        .game-section {
            animation: sectionSlideIn 0.6s ease-out;
        }

        @keyframes sectionSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Theme Toggle Button (match index.html style) */
        #themeToggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            padding: 12px 24px;
            background: #000;
            color: #fff;
            border: 4px solid #fff;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 4px 4px 0 rgba(255,255,255,0.3);
            transition: all 0.3s;
        }

        #themeToggle:hover {
            background: #fff;
            color: #000;
            border-color: #000;
        }

        /* Night mode specific styles */
        body.night-mode .game-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-color: #fff;
        }

        body.night-mode h1 {
            color: #f57cc6;
            text-shadow: 3px 3px 0 #00ffff;
        }

        body.night-mode .game-btn {
            background: linear-gradient(135deg, #00ffff 0%, #0088cc 100%);
            color: #000;
            border-color: #fff;
        }

        body.night-mode .game-btn:hover {
            background: linear-gradient(135deg, #0088cc 0%, #00ffff 100%);
        }

        body.night-mode .game-select-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body.night-mode .stat-value {
            color: #00ffff;
        }

        body.night-mode .instructions {
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border-color: #fff;
        }

        body.night-mode .player-card {
            background: linear-gradient(135deg, #2a2a4e 0%, #3a3a6e 100%);
        }

        body.night-mode .ttt-board {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 100%);
        }

        body.night-mode .ttt-cell {
            background: #2a2a4e;
        }

        body.night-mode .word-grid {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 100%);
        }

        body.night-mode .word-cell {
            background: linear-gradient(135deg, #2a2a4e 0%, #3a3a6e 100%);
        }

        body.night-mode .word-cell.selected {
            background: linear-gradient(135deg, #00ffff 0%, #0080ff 100%);
        }

        body.night-mode .hint-section {
            background: rgba(0, 0, 0, 0.5);
            border-color: #fff;
            color: #fff;
        }

        .game-container {
            background: var(--bg-secondary);
            border: 6px solid var(--border-color);
            border-radius: 20px;
            box-shadow: 12px 12px 0 var(--shadow-color);
            padding: 2rem;
            max-width: 900px;
            width: 100%;
            margin: auto;
            transform: translateY(0);
            transition: all 0.3s ease;
        }

        .game-container:hover {
            transform: translateY(-5px);
        }

        h1 {
            text-align: center;
            color: #ff00ff;
            text-shadow: 3px 3px 0 #00ffff;
            margin-bottom: 1rem;
            font-size: 2.5rem;
            animation: titleBounce 1s infinite;
        }

        @keyframes titleBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .game-canvas-wrapper {
            position: relative;
            background: #87CEEB;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
            margin-bottom: 1rem;
            cursor: crosshair;
        }

        #gameCanvas, #shooterCanvas {
            display: block;
            width: 100%;
            height: 400px;
            image-rendering: pixelated;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .game-btn {
            background: var(--button-bg);
            color: var(--text-primary);
            padding: 1rem 2rem;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 4px 4px 0 var(--shadow-color);
            text-transform: uppercase;
        }

        .game-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color);
            background: var(--button-hover);
        }

        .game-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 var(--shadow-color);
        }

        .pause-btn {
            background: linear-gradient(135deg, #ffff00 0%, #ffcc00 100%);
        }

        .pause-btn:hover {
            background: linear-gradient(135deg, #ffcc00 0%, #ffff00 100%);
        }

        .restart-btn {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: #fff;
        }

        .restart-btn:hover {
            background: linear-gradient(135deg, #cc0000 0%, #ff0000 100%);
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }

        .stat-value {
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        .instructions {
            text-align: center;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,0.9);
            border: 3px solid var(--border-color);
            border-radius: 10px;
        }

        .instructions h3 {
            color: #ff00ff;
            margin-bottom: 0.5rem;
        }

        .instructions p {
            color: var(--text-primary);
            font-size: 1rem;
            margin: 0.3rem 0;
        }

        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            padding: 2rem;
            border: 6px solid var(--border-color);
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 10;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .game-over-screen h2 {
            color: #fff;
            font-size: 2.5rem;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 1rem;
        }

        .game-over-screen p {
            color: #fff;
            font-size: 1.3rem;
            margin: 0.5rem 0;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .game-container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .game-btn {
                padding: 0.8rem 1.5rem;
                font-size: 1rem;
            }
            
            .stat-value {
                font-size: 1.5rem;
            }

            .game-select-card {
                padding: 1.5rem;
            }

            .game-select-card h2 {
                font-size: 1.5rem;
            }

            .ttt-board {
                width: 300px;
                height: 300px;
            }

            .player-info {
                flex-direction: column;
                gap: 1rem;
            }

            .vs-text {
                transform: rotate(0deg);
            }

            .word-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 0.5rem;
            }
            
            .word-cell {
                padding: 0.8rem 0.3rem;
                font-size: 1.4rem;
                min-height: 70px;
            }
        }

        /* Header controls */
        .header-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .music-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .music-btn {
            background: linear-gradient(135deg, #00ffff 0%, #0080ff 100%);
            color: white;
            border: 3px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 3px 3px 0 var(--shadow-color);
        }

        .music-btn:hover {
            transform: translate(1px, 1px);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }

        /* Game Selector Styles */
        .game-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .game-select-card {
            background: var(--card-bg);
            padding: 2rem;
            border: 6px solid var(--border-color);
            border-radius: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 8px 8px 0 var(--shadow-color);
        }

        .game-select-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 12px 12px 0 var(--shadow-color);
        }

        .game-select-card:active {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 6px 6px 0 var(--shadow-color);
        }

        .game-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: iconFloat 2s infinite;
        }

        @keyframes iconFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .game-select-card h2 {
            color: #fff;
            font-size: 2rem;
            text-shadow: 3px 3px 0 #000;
            margin-bottom: 0.5rem;
        }

        .game-select-card p {
            color: #fff;
            font-size: 1.2rem;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }

        .game-section {
            animation: fadeIn 0.5s;
            display: none;
        }

        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(20px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        .back-btn {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: #fff;
            padding: 0.8rem 1.5rem;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 4px 4px 0 var(--shadow-color);
            margin-bottom: 1rem;
        }

        .back-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color);
            background: linear-gradient(135deg, #cc0000 0%, #ff0000 100%);
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
        }

        .mobile-btn {
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
            color: #fff;
            padding: 1.5rem 2rem;
            border: 4px solid var(--border-color);
            border-radius: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 6px 6px 0 var(--shadow-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            min-width: 120px;
            touch-action: manipulation;
            user-select: none;
        }

        .mobile-btn:active {
            transform: scale(0.95);
            box-shadow: 3px 3px 0 var(--shadow-color);
        }

        .mobile-btn span:first-child {
            font-size: 2rem;
        }

        /* Tic Tac Toe Styles */
        .ttt-game-wrapper {
            width: 100%;
        }

        .ttt-header {
            margin-bottom: 2rem;
        }

        .player-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1.5rem;
        }

        .player-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 1rem 2rem;
            border: 4px solid var(--border-color);
            border-radius: 15px;
            text-align: center;
            box-shadow: 6px 6px 0 var(--shadow-color);
            transition: all 0.3s;
        }

        .player-card.active {
            transform: scale(1.1);
            box-shadow: 8px 8px 0 var(--shadow-color);
            border-color: #ff00ff;
        }

        .player-symbol {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .player-score {
            font-size: 2rem;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 2px 2px 0 #00ffff;
        }

        .vs-text {
            font-size: 2rem;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 3px 3px 0 #00ffff;
            transform: rotate(-10deg);
        }

        .turn-indicator {
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-primary);
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            padding: 1rem;
            border: 4px solid var(--border-color);
            border-radius: 15px;
            box-shadow: 6px 6px 0 var(--shadow-color);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .ttt-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 400px;
            height: 400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 6px solid var(--border-color);
            border-radius: 20px;
            box-shadow: 10px 10px 0 var(--shadow-color);
        }

        .ttt-cell {
            background: #fff;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 4px 4px 0 var(--shadow-color);
            touch-action: manipulation;
            user-select: none;
        }

        .ttt-cell:hover:not(.taken) {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        .ttt-cell:active:not(.taken) {
            transform: scale(0.95);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }

        .ttt-cell.taken {
            cursor: not-allowed;
        }

        .ttt-cell.winner {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            animation: winnerBlink 0.5s infinite;
        }

        @keyframes winnerBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .ttt-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .ttt-instructions {
            text-align: center;
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(255,255,255,0.9);
            border: 3px solid var(--border-color);
            border-radius: 10px;
        }

        .ttt-instructions h3 {
            color: #ff00ff;
            margin-bottom: 0.5rem;
        }

        .ttt-instructions p {
            color: var(--text-primary);
            font-size: 1rem;
            margin: 0.3rem 0;
        }

        .ai-difficulty {
            text-align: center;
            margin: 1rem 0;
        }

        .difficulty-selector {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .difficulty-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #000;
            padding: 0.5rem 1rem;
            border: 3px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: white;
        }

        /* Shooter Game Styles */
        .shooter-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .powerup-indicator {
            text-align: center;
            margin: 1rem 0;
        }

        .powerup-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 3px solid var(--border-color);
            border-radius: 10px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .powerup-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s;
        }

        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .shooter-game-wrapper {
            width: 100%;
        }

        .game-mode-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .mode-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.8rem 1.5rem;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 4px 4px 0 var(--shadow-color);
        }

        .mode-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }

        /* Word Match Game Styles */
        .word-game-wrapper {
            width: 100%;
            overflow: hidden;
        }

        .word-game-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .current-word {
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            padding: 1rem;
            border: 6px solid var(--border-color);
            border-radius: 15px;
            margin: 1rem auto;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .current-word h3 {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 0 #000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .word-display {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 3px 3px 0 #000;
            letter-spacing: 0.1rem;
            min-height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            word-wrap: break-word;
            text-align: center;
            padding: 0.5rem;
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.8rem;
            margin: 1.5rem 0;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 6px solid var(--border-color);
            border-radius: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Custom scrollbar for word grid */
        .word-grid::-webkit-scrollbar {
            width: 10px;
        }

        .word-grid::-webkit-scrollbar-track {
            background: #ffd700;
            border-radius: 5px;
            border: 2px solid var(--border-color);
        }

        .word-grid::-webkit-scrollbar-thumb {
            background: #ff00ff;
            border-radius: 5px;
            border: 2px solid var(--border-color);
        }

        .word-cell {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            border: 4px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 4px 4px 0 var(--shadow-color);
            user-select: none;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 90px;
            word-wrap: break-word;
            overflow: hidden;
            box-sizing: border-box;
        }

        .word-cell:hover:not(.matched):not(.selected) {
            transform: scale(1.05);
            background: linear-gradient(135deg, #ffff00 0%, #ffcc00 100%);
        }

        .word-cell:active:not(.matched):not(.selected) {
            transform: scale(0.95);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }

        .word-cell.selected {
            background: linear-gradient(135deg, #00ffff 0%, #0080ff 100%);
            transform: scale(1.05);
            color: white;
        }

        .word-cell.matched {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            cursor: default;
            animation: matchPulse 0.5s;
        }

        @keyframes matchPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .word-game-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .hint-section {
            text-align: center;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255,255,255,0.9);
            border: 3px solid var(--border-color);
            border-radius: 10px;
        }

        .hint-btn {
            background: linear-gradient(135deg, #ff9900 0%, #ff6600 100%);
            color: white;
            padding: 0.8rem 1.5rem;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 4px 4px 0 var(--shadow-color);
            margin: 0.5rem;
        }

        .hint-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }

        .hint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: 4px 4px 0 var(--shadow-color);
        }

        .hint-text {
            font-size: 1.2rem;
            color: #333;
            margin-top: 0.5rem;
            min-height: 1.5rem;
            word-wrap: break-word;
        }

        .category-selector {
            text-align: center;
            margin: 1rem 0;
        }

        .category-buttons {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .category-btn {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #000;
            padding: 0.5rem 1rem;
            border: 3px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .category-btn.active {
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            color: white;
        }
    </style>
</head>
<body>
    <!-- Theme Toggle Button -->
    <button id="themeToggle" class="comic-border">üåô Night Mode</button>
    <!-- Game Audio Controls removed from here, now in header -->
    
    <!-- Game Audio Controls removed from here, now in header -->
    
    <!-- Audio Controls (fixed position, sticky, OUTSIDE game container) -->
    <div id="story-audio-controls" style="position: fixed; bottom: 110px; right: 20px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; display: none; min-width: 180px; border: 3px solid #000; box-shadow: 4px 4px 0 rgba(0,0,0,0.3);">
        <div style="color: white;">
            <div style="font-size: 14px; margin-bottom: 5px; color: #ffd700;">Game Audio: <span id="audio-story-title"></span></div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <button id="play-story-btn" style="background: #667eea; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; flex: 1;">üîä Play</button>
                <button id="stop-story-btn" style="background: #ff6b6b; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; flex: 1;">‚èπÔ∏è Stop</button>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 12px;">Volume:</span>
                <input id="audio-volume" type="range" min="0" max="100" value="50" style="flex: 1; cursor: pointer;">
            </div>
            <div id="story-audio-status" style="font-size: 12px; margin-top: 5px; color: #aaa;">Stopped</div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="header-controls" id="headerControls">
            <button class="back-btn" onclick="window.location.href='index.html'">
                üè† BACK TO HOME
            </button>
            <button id="gameHomeBtn" class="back-btn" style="display: none;" onclick="backToSelection()">
                üè† BACK TO GAMES
            </button>
            <!-- music controls removed -->
        </div>
        
        <h1 id="gameTitle">üéÆ You've found my Easter eggüéÆ</h1>
        
        <div id="gameSelector" class="game-selector">
            <div class="game-select-card" onclick="selectGame('runner')">
                <div class="game-icon">üèÉ</div>
                <h2>RETRO RUNNER</h2>
                <p>Endless running action!</p>
            </div>
            <div class="game-select-card" onclick="selectGame('tictactoe')">
                <div class="game-icon">‚≠ï</div>
                <h2>TIC TAC TOE</h2>
                <p>Play against AI!</p>
            </div>
            <div class="game-select-card" onclick="selectGame('shooter')">
                <div class="game-icon">üéØ</div>
                <h2>BALL BLASTER</h2>
                <p>Shoot the balls!</p>
            </div>
            <div class="game-select-card" onclick="selectGame('wordmatch')">
                <div class="game-icon">üî†</div>
                <h2>WORD MATCHER</h2>
                <p>Match words & meanings!</p>
            </div>
            <div class="game-select-card" onclick="selectGame('typing')">
                <div class="game-icon">‚å®Ô∏è</div>
                <h2>TYPING TEST</h2>
                <p>Measure your speed and accuracy.</p>
            </div>
            <!-- Add this with the other game cards in the #gameSelector div -->
<div class="game-select-card" onclick="selectGame('spacecleaner')">
    <div class="game-icon">üöÄ</div>
    <h2>SPACE CLEANER</h2>
    <p>External Game - Open in new tab</p>
</div>
        </div>
        
        <div id="runnerGame" class="game-section" style="display: none;">
            <button class="back-btn" onclick="backToSelection()">‚Üê BACK</button>
            <div class="game-canvas-wrapper">
                <canvas id="gameCanvas" width="800" height="400"></canvas>
                <div id="gameOverScreen" class="game-over-screen">
                    <h2>GAME OVER!</h2>
                    <p>Final Score: <span id="finalScore">0</span></p>
                    <p>High Score: <span id="finalHighScore">0</span></p>
                    <button class="game-btn restart-btn" onclick="restartGame()">PLAY AGAIN</button>
                </div>
            </div>

            <div class="controls">
                <button id="playBtn" class="game-btn" onclick="togglePlay()">‚ñ∂Ô∏è PLAY</button>
                <button id="pauseBtn" class="game-btn pause-btn" onclick="togglePause()" style="display: none;">‚è∏Ô∏è PAUSE</button>
                <button class="game-btn restart-btn" onclick="restartGame()">üîÑ RESTART</button>
            </div>

            <div class="mobile-controls" id="mobileControls">
                <button class="mobile-btn jump-btn" ontouchstart="mobileJump(event)">
                    <span>‚¨ÜÔ∏è</span>
                    <span>JUMP</span>
                </button>
                <button class="mobile-btn duck-btn" ontouchstart="mobileDuckStart(event)" ontouchend="mobileDuckEnd(event)">
                    <span>‚¨áÔ∏è</span>
                    <span>DUCK</span>
                </button>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="scoreDisplay">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">High Score</div>
                    <div class="stat-value" id="highScoreDisplay">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value" id="speedDisplay">1x</div>
                </div>
            </div>

            <div class="instructions">
                <h3>üìñ HOW TO PLAY</h3>
                <p>‚¨ÜÔ∏è Press SPACE or UP ARROW to jump</p>
                <p>‚¨áÔ∏è Press DOWN ARROW to duck</p>
                <p>üì± On mobile: Use touch buttons</p>
                <p>üéØ Avoid obstacles and collect coins!</p>
                <p>üíé Speed increases as you progress!</p>
            </div>
        </div>

        <!-- Tic Tac Toe Game -->
        <div id="tictactoeGame" class="game-section" style="display: none;">
            <button class="back-btn" onclick="backToSelection()">‚Üê BACK</button>
            
            <div class="ttt-game-wrapper">
                <div class="ai-difficulty">
                    <h3>ü§ñ AI DIFFICULTY</h3>
                    <div class="difficulty-selector">
                        <button class="difficulty-btn active" onclick="setAIDifficulty('easy')">Easy</button>
                        <button class="difficulty-btn" onclick="setAIDifficulty('medium')">Medium</button>
                        <button class="difficulty-btn" onclick="setAIDifficulty('hard')">Hard</button>
                    </div>
                </div>
                
                <div class="ttt-header">
                    <div class="player-info">
                        <div class="player-card active" id="playerCard">
                            <div class="player-symbol">‚ùå</div>
                            <div class="player-name">YOU</div>
                            <div class="player-score" id="scoreX">0</div>
                        </div>
                        <div class="vs-text">VS</div>
                        <div class="player-card" id="aiCard">
                            <div class="player-symbol">ü§ñ</div>
                            <div class="player-name">AI</div>
                            <div class="player-score" id="scoreO">0</div>
                        </div>
                    </div>
                    <div class="turn-indicator" id="turnIndicator">
                        YOUR TURN
                    </div>
                </div>

                <div class="ttt-board" id="tttBoard">
                    <div class="ttt-cell" data-index="0" onclick="makeMove(0)"></div>
                    <div class="ttt-cell" data-index="1" onclick="makeMove(1)"></div>
                    <div class="ttt-cell" data-index="2" onclick="makeMove(2)"></div>
                    <div class="ttt-cell" data-index="3" onclick="makeMove(3)"></div>
                    <div class="ttt-cell" data-index="4" onclick="makeMove(4)"></div>
                    <div class="ttt-cell" data-index="5" onclick="makeMove(5)"></div>
                    <div class="ttt-cell" data-index="6" onclick="makeMove(6)"></div>
                    <div class="ttt-cell" data-index="7" onclick="makeMove(7)"></div>
                    <div class="ttt-cell" data-index="8" onclick="makeMove(8)"></div>
                </div>

                <div class="ttt-controls">
                    <button class="game-btn" onclick="resetTicTacToe()">üîÑ NEW GAME</button>
                    <button class="game-btn restart-btn" onclick="resetScores()">üìä RESET SCORES</button>
                </div>

                <div class="ttt-instructions">
                    <h3>üìñ HOW TO PLAY</h3>
                    <p>üéØ Get 3 in a row to win!</p>
                    <p>üì± Tap any empty cell to place your X</p>
                    <p>ü§ñ AI will automatically place O after your move</p>
                    <p>üèÜ First to get 3 marks horizontally, vertically, or diagonally wins!</p>
                </div>
            </div>

            <div id="tttWinScreen" class="game-over-screen" style="display: none;">
                <h2 id="tttWinMessage">YOU WIN!</h2>
                <p id="tttWinDetails">üéâ Congratulations! üéâ</p>
                    <button class="game-btn" onclick="resetTicTacToe()">PLAY AGAIN</button>
            </div>
        </div>

        <!-- Ball Blaster Game -->
        <div id="shooterGame" class="game-section" style="display: none;">
            <button class="back-btn" onclick="backToSelection()">‚Üê BACK</button>
            
            <div class="shooter-game-wrapper">
                <div class="game-mode-buttons">
                    <button class="mode-btn active" onclick="setShooterMode('classic')">üéØ CLASSIC</button>
                    <button class="mode-btn" onclick="setShooterMode('survival')">üíÄ SURVIVAL</button>
                    <button class="mode-btn" onclick="setShooterMode('timeattack')">‚è±Ô∏è TIME ATTACK</button>
                </div>
                
                <div class="game-canvas-wrapper" id="shooterCanvasWrapper">
                    <canvas id="shooterCanvas" width="800" height="400"></canvas>
                    <div id="shooterGameOverScreen" class="game-over-screen">
                        <h2 id="shooterGameOverTitle">GAME OVER!</h2>
                        <p>Balls Destroyed: <span id="finalBallsDestroyed">0</span></p>
                        <p>Final Score: <span id="finalShooterScore">0</span></p>
                        <p>High Score: <span id="finalShooterHighScore">0</span></p>
                        <button class="game-btn restart-btn" onclick="restartShooterGame()">PLAY AGAIN</button>
                    </div>
                </div>

                <div class="shooter-stats">
                    <div class="stat-item">
                        <div class="stat-label">SCORE</div>
                        <div class="stat-value" id="shooterScore">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">BALLS DESTROYED</div>
                        <div class="stat-value" id="ballsDestroyed">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label" id="modeSpecificLabel">TIME LEFT</div>
                        <div class="stat-value" id="modeSpecificValue">60s</div>
                    </div>
                </div>

                <div class="powerup-indicator">
                    <h3>‚ö° POWER SHOT</h3>
                    <div class="powerup-bar">
                        <div class="powerup-fill" id="powerupFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="controls">
                    <button id="shooterPlayBtn" class="game-btn" onclick="startShooterGame()">‚ñ∂Ô∏è START GAME</button>
                    <button id="shooterPauseBtn" class="game-btn pause-btn" onclick="toggleShooterPause()" style="display: none;">‚è∏Ô∏è PAUSE</button>
                    <button class="game-btn restart-btn" onclick="restartShooterGame()">üîÑ RESTART</button>
                </div>

                <div class="instructions">
                    <h3>üéØ HOW TO PLAY</h3>
                    <p>üñ±Ô∏è CLICK or TAP to shoot balls</p>
                    <p>üéØ Different balls give different points</p>
                    <p>‚ö° Fill power bar for explosive shots</p>
                    <p>üí• Red balls explode and damage nearby balls</p>
                    <p>üèÜ Destroy as many balls as possible!</p>
                    <p><strong>üéØ CLASSIC:</strong> Unlimited time, just score points</p>
                    <p><strong>üíÄ SURVIVAL:</strong> Don't let balls reach the bottom!</p>
                    <p><strong>‚è±Ô∏è TIME ATTACK:</strong> Score as many points as you can in 60 seconds!</p>
                </div>
            </div>
        </div>

        <!-- Word Match Game -->
        <div id="wordMatchGame" class="game-section" style="display: none;">
            
            
            <div class="word-game-wrapper">
                <div class="word-game-header">
                    <h2>üî† WORD MATCHER GAME üî†</h2>
                    <p>Match the word with its correct meaning!</p>
                </div>

                <div class="category-selector">
                    <h3>üìö SELECT CATEGORY</h3>
                    <div class="category-buttons">
                        <button class="category-btn active" onclick="setWordCategory('general')">General</button>
                        <button class="category-btn" onclick="setWordCategory('science')">Science</button>
                        <button class="category-btn" onclick="setWordCategory('tech')">Technology</button>
                        <button class="category-btn" onclick="setWordCategory('sports')">Sports</button>
                        <button class="category-btn" onclick="setWordCategory('food')">Food</button>
                    </div>
                </div>

                <div class="current-word">
                    <h3>CURRENT WORD:</h3>
                    <div class="word-display" id="currentWordDisplay">---</div>
                </div>

                <div class="word-grid" id="wordGrid">
                    <!-- Word cards will be generated here -->
                </div>

                <div class="word-game-stats">
                    <div class="stat-item">
                        <div class="stat-label">SCORE</div>
                        <div class="stat-value" id="wordScore">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">MATCHED</div>
                        <div class="stat-value" id="matchedCount">0/5</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">TIME</div>
                        <div class="stat-value" id="wordTime">60s</div>
                    </div>
                </div>

                <div class="hint-section">
                    <h3>üí° NEED HELP?</h3>
                    <button class="hint-btn" onclick="useHint()" id="hintBtn">GET HINT (3 LEFT)</button>
                    <div class="hint-text" id="hintText"></div>
                </div>

                <div class="controls">
                    <button id="wordPlayBtn" class="game-btn" onclick="startWordGame()">‚ñ∂Ô∏è START GAME</button>
                    <button id="wordPauseBtn" class="game-btn pause-btn" onclick="toggleWordPause()" style="display: none;">‚è∏Ô∏è PAUSE</button>
                    <button class="game-btn restart-btn" onclick="restartWordGame()">üîÑ NEW ROUND</button>
                </div>

                <div id="wordGameOverScreen" class="game-over-screen" style="display: none;">
                    <h2>ROUND COMPLETE!</h2>
                    <p>Final Score: <span id="finalWordScore">0</span></p>
                    <p>Words Matched: <span id="finalMatched">0/5</span></p>
                    <p>Time Bonus: <span id="timeBonus">0</span> points</p>
                    <button class="game-btn restart-btn" onclick="restartWordGame()">PLAY AGAIN</button>
                </div>

                <div class="instructions">
                    <h3>üìñ HOW TO PLAY</h3>
                    <p>üéØ Match the word with its correct meaning</p>
                    <p>üî† Click on a meaning card to select it</p>
                    <p>‚úÖ Correct matches earn 100 points</p>
                    <p>‚ùå Wrong matches lose 20 points</p>
                    <p>‚è±Ô∏è Complete before time runs out for bonus points!</p>
                    <p>üí° Use hints when stuck (3 per game)</p>
                    <p>üèÜ Try different categories for more fun!</p>
                </div>
            </div>
        </div>

        <!-- Space Cleaner Game (External Link) -->
<div id="spaceCleanerGame" class="game-section" style="display: none;">
    <!--button class="back-btn" onclick="backToSelection()">‚Üê BACK</button-->
    
    <div class="word-game-wrapper">
        <div class="word-game-header">
            <h2>üöÄ SPACE CLEANER üöÄ</h2>
            <p>An external game hosted on gx.games</p>
        </div>

        <div style="text-align: center; padding: 2rem;">
            <div style="background: var(--card-bg); padding: 2rem; border: 6px solid var(--border-color); border-radius: 20px; margin: 2rem 0;">
                <h3 style="color: white; text-shadow: 3px 3px 0 #000; margin-bottom: 1rem;">This game will open in a new tab</h3>
                <p style="color: white; font-size: 1.2rem; margin-bottom: 2rem;">Click the button below to play Space Cleaner on gx.games</p>
                
                <button class="game-btn" onclick="window.open('https://gx.games/games/p0v448/space-cleaner/', '_blank')" 
                        style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 1.5rem; padding: 1.5rem 3rem;">
                    üöÄ PLAY SPACE CLEANER üöÄ
                </button>
            </div>
            
            <div class="instructions">
                <h3>üìñ ABOUT THIS GAME</h3>
                <p>üéÆ This is an external game hosted on gx.games</p>
                <p>üñ±Ô∏è Click the button above to open in a new tab</p>
                <p>üì± The game may take a moment to load</p>
                <p>üîô Use the BACK button above to return to game selection</p>
                <p>üéØ Enjoy cleaning up space debris!</p>
            </div>
        </div>
    </div>
</div>
    
    
    <!-- Background/main/game music system removed -->
    
    <!-- Typing Test Game -->
    <div id="typingGame" class="game-section" style="display: none;">
        <button class="back-btn" onclick="backToSelection()">‚Üê BACK</button>

        <div class="typing-wrapper">
            <h2>‚å®Ô∏è TYPING TEST</h2>
            <p>Type the given text as quickly and accurately as you can.</p>

            <div id="typingPrompt" class="typing-prompt" style="background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; border: 3px solid var(--border-color); margin-bottom: 10px;">
                <!-- prompt will be injected here -->
            </div>

            <textarea id="typingInput" rows="4" placeholder="Start typing here..." style="width:100%; padding:10px; font-size:1rem; border-radius:8px; border:3px solid var(--border-color);"></textarea>

            <div style="display:flex; gap:10px; margin-top:10px;">
                <button id="typingStartBtn" class="game-btn" onclick="startTyping()">‚ñ∂Ô∏è START</button>
                <button id="typingResetBtn" class="game-btn" onclick="resetTyping()">üîÑ RESET</button>
            </div>

            <div class="typing-stats" style="display:flex; gap:20px; margin-top:12px;">
                <div>Time: <strong><span id="typingTime">0.0</span>s</strong></div>
                <div>Accuracy: <strong><span id="typingAccuracy">0</span>%</strong></div>
                <div>WPM: <strong><span id="typingWpm">0</span></strong></div>
            </div>
        </div>
    </div>

    <script>
        // ===== NIGHT MODE TOGGLE =====
        const themeToggle = document.getElementById('themeToggle');
        let isNightMode = localStorage.getItem('nightMode') === 'true';
        
        function initNightMode() {
            if (isNightMode) {
                document.body.classList.add('night-mode');
                themeToggle.textContent = '‚òÄÔ∏è Day Mode';
            } else {
                document.body.classList.remove('night-mode');
                themeToggle.textContent = 'üåô Night Mode';
            }
        }
        
        themeToggle.addEventListener('click', function() {
            isNightMode = !isNightMode;
            localStorage.setItem('nightMode', isNightMode);
            initNightMode();
        });
        
        // Initialize night mode
        initNightMode();

        // ===== Page Audio (adapted from stories.html) =====
        let pageAudio = null;
        let pageAudioPlaying = false;
        let pageAudioTitle = '';

        // Map games to available audio files in the workspace
        const gameAudioMap = {
            runner: 'gamemusic1.mp3',
            tictactoe: 'gamemusic2.mp3',
            shooter: 'gamemusic3.mp3',
            wordmatch: 'gamemusic4.mp3',
            typing: 'writing.mp3'
        };

        function initPageAudio(src, title) {
            // clean up any existing audio
            cleanupPageAudio();

            if (!src) {
                const audioContainer = document.getElementById('story-audio-controls');
                if (audioContainer) audioContainer.style.display = 'none';
                return;
            }

            const audio = new Audio();
            audio.id = 'page-audio-player';
            audio.loop = true;
            audio.preload = 'auto';
            audio.src = src;
            audio.style.display = 'none';
            document.body.appendChild(audio);

            pageAudio = audio;
            pageAudioTitle = title || '';

            setupPageAudioControls(audio);

            const audioContainer = document.getElementById('story-audio-controls');
            if (audioContainer) {
                audioContainer.style.display = 'block';
                audioContainer.style.zIndex = '10000';

                const titleSpan = document.getElementById('audio-story-title');
                if (titleSpan) titleSpan.textContent = pageAudioTitle;

                const statusSpan = document.getElementById('story-audio-status');
                if (statusSpan) {
                    statusSpan.textContent = 'Ready to play';
                    statusSpan.style.color = '#ffd700';
                }
            }
        }

        function setupPageAudioControls(audio) {
            const playBtn = document.getElementById('play-story-btn');
            const stopBtn = document.getElementById('stop-story-btn');
            const volumeSlider = document.getElementById('audio-volume');
            const statusSpan = document.getElementById('story-audio-status');

            if (volumeSlider) {
                audio.volume = volumeSlider.value / 100;
                volumeSlider.addEventListener('input', function() {
                    audio.volume = this.value / 100;
                });
            }

            if (playBtn) {
                const newPlayBtn = playBtn.cloneNode(true);
                playBtn.parentNode.replaceChild(newPlayBtn, playBtn);
                newPlayBtn.addEventListener('click', function() {
                    if (audio.paused) {
                        audio.play().then(() => {
                            pageAudioPlaying = true;
                            if (statusSpan) {
                                statusSpan.textContent = 'Playing';
                                statusSpan.style.color = '#4CAF50';
                            }
                            this.textContent = '‚è∏Ô∏è Pause';
                        }).catch(error => {
                            console.error('Audio playback failed:', error);
                            if (statusSpan) {
                                statusSpan.textContent = 'Error: Click to play';
                                statusSpan.style.color = '#ff6b6b';
                            }
                            showNotification('Audio playback error.');
                        });
                    } else {
                        audio.pause();
                        pageAudioPlaying = false;
                        if (statusSpan) {
                            statusSpan.textContent = 'Paused';
                            statusSpan.style.color = '#ff9800';
                        }
                        this.textContent = 'üîä Play';
                    }
                });
            }

            if (stopBtn) {
                const newStopBtn = stopBtn.cloneNode(true);
                stopBtn.parentNode.replaceChild(newStopBtn, stopBtn);
                newStopBtn.addEventListener('click', function() {
                    audio.pause();
                    audio.currentTime = 0;
                    pageAudioPlaying = false;

                    const playBtn = document.getElementById('play-story-btn');
                    if (playBtn) playBtn.textContent = 'üîä Play';

                    if (statusSpan) {
                        statusSpan.textContent = 'Stopped';
                        statusSpan.style.color = '#ff6b6b';
                    }
                });
            }

            audio.addEventListener('ended', function() {
                if (statusSpan) {
                    statusSpan.textContent = 'Ended';
                    statusSpan.style.color = '#9c27b0';
                }
                const playBtn = document.getElementById('play-story-btn');
                if (playBtn) playBtn.textContent = 'üîä Play';
                pageAudioPlaying = false;
            });

            audio.addEventListener('error', function(e) {
                console.error('Audio error:', e);
                if (statusSpan) {
                    statusSpan.textContent = 'Error loading audio';
                    statusSpan.style.color = '#ff0000';
                }
                showNotification('Could not load audio file.');
            });
        }

        function cleanupPageAudio() {
            if (pageAudio) {
                pageAudio.pause();
                pageAudio.currentTime = 0;
                if (pageAudio.parentNode) pageAudio.parentNode.removeChild(pageAudio);
                pageAudio = null;
            }

            pageAudioPlaying = false;
            pageAudioTitle = '';

            const playBtn = document.getElementById('play-story-btn');
            if (playBtn) playBtn.textContent = 'üîä Play';

            const statusSpan = document.getElementById('story-audio-status');
            if (statusSpan) {
                statusSpan.textContent = 'Stopped';
                statusSpan.style.color = '#aaa';
            }

            const audioContainer = document.getElementById('story-audio-controls');
            if (audioContainer) audioContainer.style.display = 'none';
        }

        // Minimal notification helper (copied from stories page)
        function showNotification(message) {
            let notification = document.getElementById('temp-notification');
            if (notification) notification.remove();

            notification = document.createElement('div');
            notification.id = 'temp-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
                color: white;
                padding: 15px 25px;
                border: 4px solid #000;
                border-radius: 15px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 6px 6px 0 rgba(0,0,0,0.3);
                animation: slideIn 0.5s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            if (!document.getElementById('notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
                    @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
                `;
                document.head.appendChild(style);
            }

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.5s ease-out forwards';
                setTimeout(() => {
                    if (notification.parentNode) notification.remove();
                }, 500);
            }, 3000);
        }

        // Animation setup for game selection cards (kept)
        document.addEventListener('DOMContentLoaded', function() {
            const cards = document.querySelectorAll('.game-select-card');
            cards.forEach((card, index) => {
                card.style.animationDelay = `${index * 0.1}s`;
            });

            // Wire floating Home button to return to game selector
            try {
                const homeBtn = document.getElementById('gameHomeBtn');
                if (homeBtn) {
                    homeBtn.addEventListener('click', backToSelection);
                }
            } catch (e) {
                // ignore
            }
        });

        // ===== GAME SELECTION =====
        let currentGame = null;

        function selectGame(game) {
    currentGame = game;
    document.getElementById('gameSelector').style.display = 'none';

    // Hide top-level BACK TO HOME in header when entering a game
    const topBackHeader = document.querySelector('.header-controls .back-btn');
    if (topBackHeader) topBackHeader.style.display = 'none';

    // Hide all game sections first
    const gameSections = document.querySelectorAll('.game-section');
    gameSections.forEach(section => {
        section.style.display = 'none';
    });

            // Ensure all in-section back buttons are visible by default (we'll hide per-game below)
            document.querySelectorAll('.game-section .back-btn').forEach(btn => {
                btn.style.display = '';
            });

            // Show selected game with animation
           setTimeout(() => {
        if (game === 'runner') {
            document.getElementById('gameTitle').textContent = 'üéÆ RETRO RUNNER üéÆ';
            document.getElementById('runnerGame').style.display = 'block';
            initRunnerGame();
        } else if (game === 'tictactoe') {
            document.getElementById('gameTitle').textContent = 'üéÆ TIC TAC TOE üéÆ';
            document.getElementById('tictactoeGame').style.display = 'block';
            initTicTacToe();
        } else if (game === 'shooter') {
            document.getElementById('gameTitle').textContent = 'üéÆ BALL BLASTER üéÆ';
            document.getElementById('shooterGame').style.display = 'block';
            initShooterGame();
        } else if (game === 'wordmatch') {
            document.getElementById('gameTitle').textContent = 'üéÆ WORD MATCHER üéÆ';
            document.getElementById('wordMatchGame').style.display = 'block';
            initWordGame();
        } else if (game === 'typing') {
            document.getElementById('gameTitle').textContent = '‚å®Ô∏è TYPING TEST ‚å®Ô∏è';
            document.getElementById('typingGame').style.display = 'block';
            initTypingGame();
        } else if (game === 'spacecleaner') {
            document.getElementById('gameTitle').textContent = 'üöÄ SPACE CLEANER üöÄ';
            document.getElementById('spaceCleanerGame').style.display = 'block';
            // No initialization needed for external game
        }

        // Hide the back button inside the selected game section
        try {
            const backBtn = document.querySelector(`#${game}Game .back-btn`);
            if (backBtn) backBtn.style.display = 'none';
        } catch (e) {
            // ignore
        }
    }, 50);

            // Initialize page audio for this game (if mapped)
            const _audioSrc = gameAudioMap[game];
            if (_audioSrc) {
                const _titles = {
                    runner: 'Retro Runner',
                    tictactoe: 'Tic Tac Toe',
                    shooter: 'Ball Blaster',
                    wordmatch: 'Word Matcher'
                };
                initPageAudio(_audioSrc, _titles[game] || '');
            } else {
                cleanupPageAudio();
            }

            // Show Home button in header while inside a selected game
            try {
                const homeBtn = document.getElementById('gameHomeBtn');
                if (homeBtn) homeBtn.style.display = 'inline-block';
            } catch (e) {
                // ignore
            }
        }

        function backToSelection() {
            document.getElementById('gameTitle').textContent = 'üéÆ SELECT YOUR GAME üéÆ';
            document.getElementById('gameSelector').style.display = 'grid';
            
            // Hide all game sections with fade out animation
            const gameSections = document.querySelectorAll('.game-section');
            gameSections.forEach(section => {
                section.style.opacity = '0';
                section.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    section.style.display = 'none';
                    section.style.opacity = '1';
                    section.style.transform = 'translateY(0)';
                }, 300);
            });
            
            // Stop games if playing
            if (gameState === 'playing' || gameState === 'paused') {
                gameState = 'ready';
            }
            if (shooterGameState === 'playing' || shooterGameState === 'paused') {
                shooterGameState = 'ready';
            }
            if (wordGameState === 'playing' || wordGameState === 'paused') {
                wordGameState = 'ready';
                clearInterval(wordGameTimer);
            }
            
            // Clean up page audio and typing game when returning to selection
            cleanupPageAudio();
            try { cleanupTypingGame(); } catch (e) { /* ignore if not present */ }

            // Restore top-level BACK TO HOME button in header when returning to selector
            const topBackHeader = document.querySelector('.header-controls .back-btn');
            if (topBackHeader) topBackHeader.style.display = '';

            // Hide Home button when returning to selector
            try {
                const homeBtn = document.getElementById('gameHomeBtn');
                if (homeBtn) homeBtn.style.display = 'none';
            } catch (e) {
                // ignore
            }
        }

        // ===== TYPING TEST GAME =====

        // Typing test state
        let typingPrompts = [
            'The quick brown fox jumps over the lazy dog.',
            'Practice makes perfect; keep typing and improving each day.',
            'Typing fast requires accuracy, focus, and consistent practice.',
            'Hello world! This is a simple typing accuracy test.',
            'A good programmer reads documentation before coding.',
            'Clean code is easy to read and simple to maintain.',
            'Small, frequent commits make it easier to track changes.',
            'Back up your work regularly to avoid losing progress.',
            'Clear variable names reduce confusion and bugs.',
            'Write tests to ensure your code behaves as expected.',
            'Refactoring improves structure without changing behavior.',
            'Break problems into small steps to simplify solutions.',
            'Design with the user in mind to create better experiences.',
            'Consistent style makes a project easier for teams to follow.',
            'Comment why code does something, not what it does.',
            'Keep functions short and focused on a single task.',
            'Automate repetitive tasks to save time and avoid errors.',
            'Learn keyboard shortcuts to speed up your workflow.',
            'Ask for feedback often to improve your work quickly.',
            'A clear README helps others use and contribute to your project.',
            'Remove unused code to reduce surface for bugs.',
            'Make incremental improvements to avoid big regressions.',
            'Use meaningful commit messages for future reference.',
            'Pair programming is a great way to share knowledge.',
            'When stuck, take a break and revisit the problem later.',
            'Keep dependencies up to date to reduce security risks.',
            'Optimize only after measuring performance bottlenecks.',
            'Design APIs with simplicity and flexibility in balance.',
            'Use version control to collaborate and track history.',
            'Celebrate small wins and learn from each mistake.'
        ];
        let typingTarget = '';
        let typingTimerInterval = null;
        let typingStartTime = null;
        let typingRunning = false;

        // cumulative totals across sentences (do not reset on Enter)
        let typingTotalTyped = 0;
        let typingTotalCorrect = 0;
        let typingTotalElapsedMs = 0;

        function initTypingGame() {
            const promptEl = document.getElementById('typingPrompt');
            const inputEl = document.getElementById('typingInput');
            const timeEl = document.getElementById('typingTime');
            const accEl = document.getElementById('typingAccuracy');
            const wpmEl = document.getElementById('typingWpm');

            // Choose a random prompt
            typingTarget = typingPrompts[Math.floor(Math.random() * typingPrompts.length)];
            if (promptEl) promptEl.textContent = typingTarget;

            // Reset UI and totals
            if (inputEl) {
                inputEl.value = '';
                inputEl.disabled = false;
            }
            if (timeEl) timeEl.textContent = '0.0';
            if (accEl) accEl.textContent = '0';
            if (wpmEl) wpmEl.textContent = '0';

            typingStartTime = null;
            typingRunning = false;
            if (typingTimerInterval) {
                clearInterval(typingTimerInterval);
                typingTimerInterval = null;
            }

            typingTotalTyped = 0;
            typingTotalCorrect = 0;
            typingTotalElapsedMs = 0;

            // live input handler to update accuracy and WPM
            if (inputEl) {
                inputEl.removeEventListener('input', typingInputHandler);
                inputEl.addEventListener('input', typingInputHandler);
                inputEl.removeEventListener('keydown', typingKeydownHandler);
                inputEl.addEventListener('keydown', typingKeydownHandler);
            }
        }

        function typingInputHandler(e) {
            const input = e.target.value;
            updateTypingStats(input);
        }

        function typingKeydownHandler(e) {
            // When Enter is pressed, finalize current sentence into totals and load a new one
            if (e.key === 'Enter') {
                e.preventDefault();

                const inputEl = document.getElementById('typingInput');
                const typed = inputEl ? inputEl.value : '';

                // accumulate current typed into totals
                const typedLen = typed.length;
                const correct = calculateCorrectChars(typed, typingTarget);
                typingTotalTyped += typedLen;
                typingTotalCorrect += correct;

                // add elapsed since typingStartTime into totals, but keep timer running
                if (typingStartTime) {
                    typingTotalElapsedMs += (Date.now() - typingStartTime);
                    // reset start time to now so timer continues measuring next sentence
                    typingStartTime = Date.now();
                }

                // choose a new prompt
                typingTarget = typingPrompts[Math.floor(Math.random() * typingPrompts.length)];
                const promptEl = document.getElementById('typingPrompt');
                if (promptEl) promptEl.textContent = typingTarget;

                // clear input for the next sentence but keep timer running
                if (inputEl) {
                    inputEl.value = '';
                    inputEl.disabled = false;
                    inputEl.focus();
                }

                // update stats display (cumulative)
                updateTypingStats('');

                showNotification('Loaded new sentence to test.');
            }
        }

        function startTyping() {
            const startBtn = document.getElementById('typingStartBtn');
            const inputEl = document.getElementById('typingInput');

            if (!typingRunning) {
                // start
                typingRunning = true;
                typingStartTime = Date.now();
                typingTimerInterval = setInterval(() => {
                    const elapsedMs = typingTotalElapsedMs + (typingStartTime ? (Date.now() - typingStartTime) : 0);
                    const elapsed = elapsedMs / 1000;
                    const timeEl = document.getElementById('typingTime');
                    if (timeEl) timeEl.textContent = elapsed.toFixed(1);

                    // update accuracy/WPM live using current input
                    const inputEl = document.getElementById('typingInput');
                    const current = inputEl ? inputEl.value : '';
                    updateTypingStats(current);
                }, 100);
                if (startBtn) startBtn.textContent = '‚è∏Ô∏è STOP';
                if (inputEl) inputEl.focus();
            } else {
                // stop / finish
                typingRunning = false;
                if (typingTimerInterval) {
                    clearInterval(typingTimerInterval);
                    typingTimerInterval = null;
                }
                if (startBtn) startBtn.textContent = '‚ñ∂Ô∏è START';
                // final evaluation
                const typed = document.getElementById('typingInput').value;
                finalizeTyping(typed);
            }
        }

        function resetTyping() {
            const inputEl = document.getElementById('typingInput');
            if (typingTimerInterval) {
                clearInterval(typingTimerInterval);
                typingTimerInterval = null;
            }
            typingRunning = false;
            typingStartTime = null;
            if (inputEl) {
                inputEl.value = '';
                inputEl.disabled = false;
            }
            const timeEl = document.getElementById('typingTime');
            const accEl = document.getElementById('typingAccuracy');
            const wpmEl = document.getElementById('typingWpm');
            if (timeEl) timeEl.textContent = '0.0';
            if (accEl) accEl.textContent = '0';
            if (wpmEl) wpmEl.textContent = '0';
            const startBtn = document.getElementById('typingStartBtn');
            if (startBtn) startBtn.textContent = '‚ñ∂Ô∏è START';

            // reset cumulative totals
            typingTotalTyped = 0;
            typingTotalCorrect = 0;
            typingTotalElapsedMs = 0;
        }

        function updateTypingStats(typed) {
            const accEl = document.getElementById('typingAccuracy');
            const wpmEl = document.getElementById('typingWpm');

            // compute cumulative totals (include current typed)
            const currentCorrect = calculateCorrectChars(typed, typingTarget);
            const currentTyped = typed.length;
            const totalTyped = typingTotalTyped + currentTyped;
            const totalCorrect = typingTotalCorrect + currentCorrect;

            let accuracy = 0;
            if (totalTyped > 0) accuracy = Math.round((totalCorrect / totalTyped) * 100);
            if (accEl) accEl.textContent = accuracy.toString();

            // compute elapsed seconds cumulative
            let elapsedMs = typingTotalElapsedMs;
            if (typingRunning && typingStartTime) elapsedMs += (Date.now() - typingStartTime);
            const elapsedSec = Math.max(0.001, elapsedMs / 1000);

            const wpm = Math.round(((totalTyped / 5) / (elapsedSec / 60)) || 0);
            if (wpmEl) wpmEl.textContent = isFinite(wpm) ? String(wpm) : '0';
        }

        function calculateCorrectChars(typed, target) {
            let correct = 0;
            for (let i = 0; i < typed.length; i++) {
                if (i < target.length && typed[i] === target[i]) correct++;
            }
            return correct;
        }

        function finalizeTyping(typed) {
            // final stats already updated live; disable input
            const inputEl = document.getElementById('typingInput');
            if (inputEl) inputEl.disabled = true;
            // accumulate final typed into totals
            const typedLen = typed.length;
            const correct = calculateCorrectChars(typed, typingTarget);
            typingTotalTyped += typedLen;
            typingTotalCorrect += correct;

            // add elapsed since start
            if (typingStartTime) {
                typingTotalElapsedMs += (Date.now() - typingStartTime);
                typingStartTime = null;
            }

            updateTypingStats('');
            showNotification('Typing test complete!');
        }

        function cleanupTypingGame() {
            if (typingTimerInterval) {
                clearInterval(typingTimerInterval);
                typingTimerInterval = null;
            }
            typingRunning = false;
            try {
                const inputEl = document.getElementById('typingInput');
                if (inputEl) {
                    inputEl.removeEventListener('input', typingInputHandler);
                    inputEl.removeEventListener('keydown', typingKeydownHandler);
                }
            } catch (e) {
                // ignore
            }
        }

        // ===== RETRO RUNNER GAME =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = 'ready'; // ready, playing, paused, gameOver
        let score = 0;
        let highScore = localStorage.getItem('retroRunnerHighScore') || 0;
        let gameSpeed = 6;
        let frameCount = 0;

        // Player
        const player = {
            x: 100,
            y: canvas.height - 100,
            width: 40,
            height: 50,
            velocityY: 0,
            gravity: 0.8,
            jumpPower: -15,
            isJumping: false,
            isDucking: false,
            normalHeight: 50,
            duckHeight: 30
        };

        // Obstacles
        let obstacles = [];
        const obstacleFrequency = 120;

        // Coins
        let coins = [];
        const coinFrequency = 80;

        // Ground
        const groundY = canvas.height - 50;

        // Input handling
        let keys = {};

        // Prevent page scrolling with arrow keys and space (but allow typing in inputs)
        document.addEventListener('keydown', (e) => {
            // If the user is typing into an input/textarea or contentEditable, don't intercept keys
            try {
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
                    return;
                }
            } catch (err) {
                // ignore if any error reading activeElement
            }

            // Prevent default behavior for game controls
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }

            keys[e.code] = true;
            
            if ((e.code === 'Space' || e.code === 'ArrowUp') && gameState === 'playing' && !player.isJumping) {
                player.velocityY = player.jumpPower;
                player.isJumping = true;
                playSound('jump');
            }
            
            if (e.code === 'ArrowDown' && gameState === 'playing' && !player.isJumping) {
                player.isDucking = true;
                player.height = player.duckHeight;
                player.y = groundY - player.duckHeight;
            }
        });

        document.addEventListener('keyup', (e) => {
            // If focus is on an input/textarea/contentEditable, don't intercept
            try {
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
                    return;
                }
            } catch (err) {
                // ignore
            }

            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }

            keys[e.code] = false;
            
            if (e.code === 'ArrowDown') {
                player.isDucking = false;
                player.height = player.normalHeight;
                if (!player.isJumping) {
                    player.y = groundY - player.normalHeight;
                }
            }
        });

        // Mobile touch controls
        function mobileJump(e) {
            e.preventDefault();
            if (gameState === 'playing' && !player.isJumping) {
                player.velocityY = player.jumpPower;
                player.isJumping = true;
                playSound('jump');
            }
        }

        function mobileDuckStart(e) {
            e.preventDefault();
            if (gameState === 'playing' && !player.isJumping) {
                player.isDucking = true;
                player.height = player.duckHeight;
                player.y = groundY - player.duckHeight;
            }
        }

        function mobileDuckEnd(e) {
            e.preventDefault();
            player.isDucking = false;
            player.height = player.normalHeight;
            if (!player.isJumping) {
                player.y = groundY - player.normalHeight;
            }
        }

        // Draw functions
        function drawPlayer() {
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // Face
            ctx.fillStyle = '#000';
            ctx.fillRect(player.x + 10, player.y + 10, 5, 5); // Eye 1
            ctx.fillRect(player.x + 25, player.y + 10, 5, 5); // Eye 2
            
            // Smile
            if (!player.isDucking) {
                ctx.fillRect(player.x + 10, player.y + 25, 20, 3);
            }
            
            // Border
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(player.x, player.y, player.width, player.height);
        }

        function drawGround() {
            // Grass
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(0, groundY, canvas.width, 50);
            
            // Dirt pattern
            ctx.fillStyle = '#228B22';
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.fillRect(i + (frameCount % 40), groundY + 10, 20, 40);
            }
            
            // Border
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, groundY, canvas.width, 50);
        }

        function drawObstacle(obstacle) {
            if (obstacle.type === 'cactus') {
                // Cactus
                ctx.fillStyle = '#228B22';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Arms
                ctx.fillRect(obstacle.x - 10, obstacle.y + 15, 10, 15);
                ctx.fillRect(obstacle.x + obstacle.width, obstacle.y + 15, 10, 15);
                
                // Border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            } else if (obstacle.type === 'rock') {
                // Rock
                ctx.fillStyle = '#696969';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Highlights
                ctx.fillStyle = '#A9A9A9';
                ctx.fillRect(obstacle.x + 5, obstacle.y + 5, 10, 10);
                
                // Border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            } else if (obstacle.type === 'bird') {
                // Bird (flying)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Wings
                const wingOffset = Math.sin(frameCount * 0.3) * 5;
                ctx.fillRect(obstacle.x - 10, obstacle.y + wingOffset, 10, 5);
                ctx.fillRect(obstacle.x + obstacle.width, obstacle.y + wingOffset, 10, 5);
                
                // Border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
        }

        function drawCoin(coin) {
            const pulseSize = Math.sin(frameCount * 0.1) * 3;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(coin.x, coin.y, coin.radius + pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner circle
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.arc(coin.x, coin.y, coin.radius - 5 + pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Border
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(coin.x, coin.y, coin.radius + pulseSize, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawSky() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, groundY);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, groundY);
            
            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const cloudX1 = (frameCount * 0.5) % (canvas.width + 100) - 100;
            const cloudX2 = (frameCount * 0.3) % (canvas.width + 150) - 150;
            
            // Cloud 1
            ctx.beginPath();
            ctx.arc(cloudX1, 60, 20, 0, Math.PI * 2);
            ctx.arc(cloudX1 + 25, 60, 25, 0, Math.PI * 2);
            ctx.arc(cloudX1 + 50, 60, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Cloud 2
            ctx.beginPath();
            ctx.arc(cloudX2, 120, 25, 0, Math.PI * 2);
            ctx.arc(cloudX2 + 30, 120, 30, 0, Math.PI * 2);
            ctx.arc(cloudX2 + 60, 120, 25, 0, Math.PI * 2);
            ctx.fill();
        }

        // Game logic
        function updatePlayer() {
            if (player.isJumping || player.y < groundY - player.height) {
                player.velocityY += player.gravity;
                player.y += player.velocityY;
                
                if (player.y >= groundY - player.height) {
                    player.y = groundY - player.height;
                    player.velocityY = 0;
                    player.isJumping = false;
                }
            }
        }

        function spawnObstacle() {
            if (frameCount % obstacleFrequency === 0) {
                const types = ['cactus', 'rock', 'bird'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let obstacle = {
                    x: canvas.width,
                    width: 30,
                    height: 40,
                    type: type
                };
                
                if (type === 'bird') {
                    obstacle.y = groundY - 100 - Math.random() * 50;
                    obstacle.height = 25;
                } else {
                    obstacle.y = groundY - obstacle.height;
                }
                
                obstacles.push(obstacle);
            }
        }

        function spawnCoin() {
            if (frameCount % coinFrequency === 0 && Math.random() > 0.3) {
                coins.push({
                    x: canvas.width,
                    y: groundY - 80 - Math.random() * 100,
                    radius: 15,
                    collected: false
                });
            }
        }

        function updateObstacles() {
            obstacles = obstacles.filter(obstacle => {
                obstacle.x -= gameSpeed;
                return obstacle.x + obstacle.width > 0;
            });
        }

        function updateCoins() {
            coins = coins.filter(coin => {
                coin.x -= gameSpeed;
                
                // Check collection
                if (!coin.collected) {
                    const dx = player.x + player.width/2 - coin.x;
                    const dy = player.y + player.height/2 - coin.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < player.width/2 + coin.radius) {
                        coin.collected = true;
                        score += 10;
                        playSound('coin');
                        return false;
                    }
                }
                
                return coin.x + coin.radius > 0;
            });
        }

        function checkCollision() {
            for (let obstacle of obstacles) {
                if (player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y) {
                    gameOver();
                    return;
                }
            }
        }

        function updateScore() {
            if (frameCount % 10 === 0) {
                score += 1;
            }
            
            // Increase speed
            gameSpeed = 6 + Math.floor(score / 100) * 0.5;
        }

        function updateDisplay() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('highScoreDisplay').textContent = highScore;
            document.getElementById('speedDisplay').textContent = (gameSpeed / 6).toFixed(1) + 'x';
        }

        // Game loop
        function gameLoop() {
            if (gameState !== 'playing') return;
            
            frameCount++;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw
            drawSky();
            drawGround();
            
            coins.forEach(drawCoin);
            obstacles.forEach(drawObstacle);
            drawPlayer();
            
            // Update
            updatePlayer();
            spawnObstacle();
            spawnCoin();
            updateObstacles();
            updateCoins();
            checkCollision();
            updateScore();
            updateDisplay();
            
            requestAnimationFrame(gameLoop);
        }

        // Game controls
        function togglePlay() {
            if (gameState === 'ready' || gameState === 'gameOver') {
                startGame();
            }
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('playBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            score = 0;
            gameSpeed = 6;
            frameCount = 0;
            obstacles = [];
            coins = [];
            
            player.y = groundY - player.normalHeight;
            player.velocityY = 0;
            player.isJumping = false;
            player.isDucking = false;
            player.height = player.normalHeight;
            
            gameLoop();
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è RESUME';
                document.getElementById('pauseBtn').style.background = 'linear-gradient(135deg, #00ff00 0%, #00cc00 100%)';
            } else if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è PAUSE';
                document.getElementById('pauseBtn').style.background = 'linear-gradient(135deg, #ffff00 0%, #ffcc00 100%)';
                gameLoop();
            }
        }

        function restartGame() {
            if (gameState === 'gameOver') {
                gameState = 'ready';
            }
            startGame();
        }

        function gameOver() {
            gameState = 'gameOver';
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('retroRunnerHighScore', highScore);
            }
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalHighScore').textContent = highScore;
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('playBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            
            playSound('gameOver');
        }

        // Sound effects
        function playSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                if (type === 'jump') {
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                } else if (type === 'coin') {
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'gameOver') {
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } else if (type === 'tttMove') {
                    oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } else if (type === 'tttWin') {
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1000, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                } else if (type === 'tttDraw') {
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(450, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                } else if (type === 'shoot') {
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } else if (type === 'explosion') {
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                } else if (type === 'powerup') {
                    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                } else if (type === 'correct') {
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                } else if (type === 'wrong') {
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                } else if (type === 'complete') {
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                }
            } catch (e) {
                console.log("Audio not supported");
            }
        }

        // Initialize
        function initRunnerGame() {
            updateDisplay();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSky();
            drawGround();
            drawPlayer();
            
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 40px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('PRESS PLAY TO START!', canvas.width/2, canvas.height/2 - 50);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('PRESS PLAY TO START!', canvas.width/2, canvas.height/2 - 50);
            
            ctx.font = 'bold 24px Comic Sans MS';
            ctx.fillStyle = '#00ffff';
            ctx.fillText('Use SPACE or ‚Üë to jump', canvas.width/2, canvas.height/2 + 10);
            ctx.fillText('Use ‚Üì to duck', canvas.width/2, canvas.height/2 + 45);
        }

        // ===== TIC TAC TOE GAME =====
        let tttBoard = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X'; // Player is always X
        let tttGameActive = true;
        let aiDifficulty = 'medium'; // 'easy', 'medium', 'hard'
        let tttScores = {
            X: localStorage.getItem('tttScoreX') || 0,
            O: localStorage.getItem('tttScoreO') || 0
        };

        const winPatterns = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6] // Diagonals
        ];

        function initTicTacToe() {
            updateTTTScores();
            updateTurnIndicator();
        }

        function setAIDifficulty(difficulty) {
            aiDifficulty = difficulty;
            
            // Update UI
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function makeMove(index) {
            const cell = document.querySelector(`.ttt-cell[data-index="${index}"]`);
            
            if (tttBoard[index] !== '' || !tttGameActive || currentPlayer !== 'X') {
                return;
            }

            tttBoard[index] = 'X';
            cell.textContent = '‚ùå';
            cell.classList.add('taken');
            
            playSound('tttMove');

            if (checkWinner()) {
                endTTTGame('X');
            } else if (tttBoard.every(cell => cell !== '')) {
                endTTTGame('draw');
            } else {
                currentPlayer = 'O';
                updateTurnIndicator();
                
                // AI move
                setTimeout(makeAIMove, 500);
            }
        }

        function makeAIMove() {
            if (!tttGameActive || currentPlayer !== 'O') return;
            
            let moveIndex;
            
            switch (aiDifficulty) {
                case 'easy':
                    moveIndex = getRandomMove();
                    break;
                case 'medium':
                    moveIndex = getMediumAIMove();
                    break;
                case 'hard':
                    moveIndex = getHardAIMove();
                    break;
            }
            
            if (moveIndex !== -1) {
                const cell = document.querySelector(`.ttt-cell[data-index="${moveIndex}"]`);
                tttBoard[moveIndex] = 'O';
                cell.textContent = '‚≠ï';
                cell.classList.add('taken');
                
                playSound('tttMove');
                
                if (checkWinner()) {
                    endTTTGame('O');
                } else if (tttBoard.every(cell => cell !== '')) {
                    endTTTGame('draw');
                } else {
                    currentPlayer = 'X';
                    updateTurnIndicator();
                }
            }
        }

        function getRandomMove() {
            const emptyCells = tttBoard.map((cell, index) => cell === '' ? index : -1).filter(index => index !== -1);
            return emptyCells.length > 0 ? emptyCells[Math.floor(Math.random() * emptyCells.length)] : -1;
        }

        function getMediumAIMove() {
            // Try to win first
            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (tttBoard[a] === 'O' && tttBoard[b] === 'O' && tttBoard[c] === '') return c;
                if (tttBoard[a] === 'O' && tttBoard[c] === 'O' && tttBoard[b] === '') return b;
                if (tttBoard[b] === 'O' && tttBoard[c] === 'O' && tttBoard[a] === '') return a;
            }
            
            // Block player from winning
            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (tttBoard[a] === 'X' && tttBoard[b] === 'X' && tttBoard[c] === '') return c;
                if (tttBoard[a] === 'X' && tttBoard[c] === 'X' && tttBoard[b] === '') return b;
                if (tttBoard[b] === 'X' && tttBoard[c] === 'X' && tttBoard[a] === '') return a;
            }
            
            // Take center if available
            if (tttBoard[4] === '') return 4;
            
            // Take corners if available
            const corners = [0, 2, 6, 8];
            const availableCorners = corners.filter(index => tttBoard[index] === '');
            if (availableCorners.length > 0) {
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }
            
            // Take any available move
            return getRandomMove();
        }

        function getHardAIMove() {
            // Use minimax algorithm for hard difficulty
            return minimax(tttBoard, 'O').index;
        }

        function minimax(newBoard, player) {
            const emptyCells = newBoard.map((cell, index) => cell === '' ? index : -1).filter(index => index !== -1);
            
            // Check for terminal states
            if (checkWinForPlayer(newBoard, 'X')) {
                return {score: -10};
            } else if (checkWinForPlayer(newBoard, 'O')) {
                return {score: 10};
            } else if (emptyCells.length === 0) {
                return {score: 0};
            }
            
            const moves = [];
            
            for (let i = 0; i < emptyCells.length; i++) {
                const move = {};
                move.index = emptyCells[i];
                
                newBoard[emptyCells[i]] = player;
                
                if (player === 'O') {
                    const result = minimax(newBoard, 'X');
                    move.score = result.score;
                } else {
                    const result = minimax(newBoard, 'O');
                    move.score = result.score;
                }
                
                newBoard[emptyCells[i]] = '';
                moves.push(move);
            }
            
            let bestMove;
            if (player === 'O') {
                let bestScore = -10000;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score > bestScore) {
                        bestScore = moves[i].score;
                        bestMove = i;
                    }
                }
            } else {
                let bestScore = 10000;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score < bestScore) {
                        bestScore = moves[i].score;
                        bestMove = i;
                    }
                }
            }
            
            return moves[bestMove];
        }

        function checkWinForPlayer(board, player) {
            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] === player && board[b] === player && board[c] === player) {
                    return true;
                }
            }
            return false;
        }

        function checkWinner() {
            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c]) {
                    highlightWinningCells(pattern);
                    return true;
                }
            }
            return false;
        }

        function highlightWinningCells(pattern) {
            pattern.forEach(index => {
                const cell = document.querySelector(`.ttt-cell[data-index="${index}"]`);
                cell.classList.add('winner');
            });
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const playerCard = document.getElementById('playerCard');
            const aiCard = document.getElementById('aiCard');
            
            if (currentPlayer === 'X') {
                indicator.textContent = `YOUR TURN`;
                playerCard.classList.add('active');
                aiCard.classList.remove('active');
            } else {
                indicator.textContent = `AI'S TURN`;
                aiCard.classList.add('active');
                playerCard.classList.remove('active');
            }
        }

        function updateTTTScores() {
            document.getElementById('scoreX').textContent = tttScores.X;
            document.getElementById('scoreO').textContent = tttScores.O;
        }

        function endTTTGame(winner) {
            tttGameActive = false;
            
            const winScreen = document.getElementById('tttWinScreen');
            const winMessage = document.getElementById('tttWinMessage');
            const winDetails = document.getElementById('tttWinDetails');
            
            if (winner === 'draw') {
                winMessage.textContent = "IT'S A DRAW!";
                winDetails.textContent = 'ü§ù Good game! Try again! ü§ù';
                playSound('tttDraw');
            } else {
                const winnerName = winner === 'X' ? 'YOU' : 'AI';
                winMessage.textContent = `${winnerName} WIN!`;
                winDetails.textContent = 'üéâ Congratulations! üéâ';
                tttScores[winner]++;
                localStorage.setItem(`tttScore${winner}`, tttScores[winner]);
                updateTTTScores();
                playSound('tttWin');
            }
            
            setTimeout(() => {
                winScreen.style.display = 'block';
            }, 500);
        }

        function resetTicTacToe() {
            tttBoard = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = 'X';
            tttGameActive = true;
            
            const cells = document.querySelectorAll('.ttt-cell');
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('taken', 'winner');
            });
            
            document.getElementById('tttWinScreen').style.display = 'none';
            updateTurnIndicator();
        }

        function resetScores() {
            if (confirm('Are you sure you want to reset all scores?')) {
                tttScores.X = 0;
                tttScores.O = 0;
                localStorage.setItem('tttScoreX', 0);
                localStorage.setItem('tttScoreO', 0);
                updateTTTScores();
                playSound('tttDraw');
            }
        }

        // ===== BALL BLASTER GAME =====
        const shooterCanvas = document.getElementById('shooterCanvas');
        const shooterCtx = shooterCanvas.getContext('2d');

        // Game state
        let shooterGameState = 'ready'; // ready, playing, paused, gameOver
        let shooterScore = 0;
        let shooterHighScore = localStorage.getItem('ballBlasterHighScore') || 0;
        let ballsDestroyed = 0;
        let powerLevel = 0;
        let isPowerShotActive = false;
        let powerShotTimer = 0;
        const POWER_SHOT_DURATION = 300; // 5 seconds at 60fps
        const MAX_POWER = 100;

        // Game mode
        let shooterMode = 'classic'; // 'classic', 'survival', 'timeattack'
        let gameTime = 60; // seconds for time attack
        let ballsMissed = 0;
        const MAX_MISSED_BALLS = 10; // for survival mode

        // Balls array
        let balls = [];
        let explosions = [];
        let particles = [];

        // Ball types with different properties
        const ballTypes = [
            { color: '#FF6B6B', radius: 25, points: 10, speed: 1.5, health: 1 }, // Red - explosive
            { color: '#4ECDC4', radius: 20, points: 20, speed: 2.0, health: 1 }, // Teal - fast
            { color: '#FFD166', radius: 30, points: 5, speed: 1.0, health: 2 },  // Yellow - big & tough
            { color: '#06D6A0', radius: 15, points: 30, speed: 2.5, health: 1 }, // Green - small & fast
            { color: '#118AB2', radius: 35, points: 3, speed: 0.8, health: 3 },  // Blue - huge & slow
            { color: '#EF476F', radius: 18, points: 25, speed: 1.8, health: 1 }, // Pink - medium
            { color: '#073B4C', radius: 22, points: 15, speed: 1.3, health: 2 }  // Dark blue - medium tough
        ];

        // Initialize game
        function initShooterGame() {
            updateShooterDisplay();
            drawShooterStartScreen();
            
            // Set up mouse/touch events
            shooterCanvas.addEventListener('mousedown', handleShoot);
            shooterCanvas.addEventListener('touchstart', handleTouchShoot);
            
            // Set cursor to crosshair
            document.getElementById('shooterCanvasWrapper').style.cursor = 'crosshair';
        }

        function setShooterMode(mode) {
            shooterMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update labels based on mode
            const label = document.getElementById('modeSpecificLabel');
            const value = document.getElementById('modeSpecificValue');
            
            switch(mode) {
                case 'classic':
                    label.textContent = 'TIME PLAYED';
                    value.textContent = '0s';
                    break;
                case 'survival':
                    label.textContent = 'BALLS MISSED';
                    value.textContent = '0/' + MAX_MISSED_BALLS;
                    break;
                case 'timeattack':
                    label.textContent = 'TIME LEFT';
                    value.textContent = gameTime + 's';
                    break;
            }
            
            restartShooterGame();
        }

        function drawShooterStartScreen() {
            shooterCtx.clearRect(0, 0, shooterCanvas.width, shooterCanvas.height);
            
            // Draw background
            const gradient = shooterCtx.createLinearGradient(0, 0, 0, shooterCanvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            shooterCtx.fillStyle = gradient;
            shooterCtx.fillRect(0, 0, shooterCanvas.width, shooterCanvas.height);
            
            // Draw title
            shooterCtx.fillStyle = '#ff00ff';
            shooterCtx.font = 'bold 50px Comic Sans MS';
            shooterCtx.textAlign = 'center';
            shooterCtx.fillText('BALL BLASTER', shooterCanvas.width/2, shooterCanvas.height/2 - 80);
            shooterCtx.strokeStyle = '#00ffff';
            shooterCtx.lineWidth = 4;
            shooterCtx.strokeText('BALL BLASTER', shooterCanvas.width/2, shooterCanvas.height/2 - 80);
            
            // Draw instructions
            shooterCtx.fillStyle = '#00ffff';
            shooterCtx.font = 'bold 24px Comic Sans MS';
            shooterCtx.fillText('CLICK or TAP to shoot balls!', shooterCanvas.width/2, shooterCanvas.height/2 - 20);
            shooterCtx.fillText('Different balls = Different points', shooterCanvas.width/2, shooterCanvas.height/2 + 20);
            shooterCtx.fillText('Press START GAME to begin!', shooterCanvas.width/2, shooterCanvas.height/2 + 60);
            
            // Draw sample balls
            const sampleBalls = [
                {type: 0, x: shooterCanvas.width/2 - 150, y: shooterCanvas.height/2 + 120},
                {type: 1, x: shooterCanvas.width/2 - 90, y: shooterCanvas.height/2 + 120},
                {type: 2, x: shooterCanvas.width/2 - 30, y: shooterCanvas.height/2 + 120},
                {type: 3, x: shooterCanvas.width/2 + 30, y: shooterCanvas.height/2 + 120},
                {type: 4, x: shooterCanvas.width/2 + 90, y: shooterCanvas.height/2 + 120},
                {type: 5, x: shooterCanvas.width/2 + 150, y: shooterCanvas.height/2 + 120}
            ];
            
            sampleBalls.forEach(ball => {
                const ballType = ballTypes[ball.type];
                drawBall(ball.x, ball.y, ballType);
                
                // Draw points
                shooterCtx.fillStyle = '#ffffff';
                shooterCtx.font = 'bold 16px Comic Sans MS';
                shooterCtx.textAlign = 'center';
                shooterCtx.fillText(ballType.points + ' pts', ball.x, ball.y + ballType.radius + 25);
            });
        }

        function drawBall(x, y, ballType) {
            // Draw glow effect for power shot
            if (isPowerShotActive) {
                shooterCtx.shadowColor = ballType.color;
                shooterCtx.shadowBlur = 20;
            }
            
            // Draw main ball
            shooterCtx.beginPath();
            shooterCtx.arc(x, y, ballType.radius, 0, Math.PI * 2);
            shooterCtx.fillStyle = ballType.color;
            shooterCtx.fill();
            
            // Draw inner highlight
            shooterCtx.beginPath();
            shooterCtx.arc(x - ballType.radius * 0.3, y - ballType.radius * 0.3, ballType.radius * 0.4, 0, Math.PI * 2);
            shooterCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            shooterCtx.fill();
            
            // Draw border
            shooterCtx.strokeStyle = '#000';
            shooterCtx.lineWidth = 3;
            shooterCtx.stroke();
            
            // Reset shadow
            shooterCtx.shadowBlur = 0;
            
            // Draw health indicator for balls with health > 1
            if (ballType.health > 1) {
                shooterCtx.fillStyle = '#fff';
                shooterCtx.font = 'bold ' + (ballType.radius * 0.5) + 'px Comic Sans MS';
                shooterCtx.textAlign = 'center';
                shooterCtx.textBaseline = 'middle';
                shooterCtx.fillText(ballType.health, x, y);
            }
        }

        function drawExplosion(x, y, radius) {
            // Draw explosion particles
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    radius: Math.random() * 5 + 2,
                    color: ['#FF6B6B', '#FFD166', '#FF9E00'][Math.floor(Math.random() * 3)],
                    life: 30
                });
            }
        }

        function drawParticles() {
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                shooterCtx.globalAlpha = particle.life / 30;
                shooterCtx.beginPath();
                shooterCtx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                shooterCtx.fillStyle = particle.color;
                shooterCtx.fill();
                shooterCtx.globalAlpha = 1;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
        }

        function spawnBall() {
            const type = Math.floor(Math.random() * ballTypes.length);
            const ballType = ballTypes[type];
            
            balls.push({
                x: Math.random() * (shooterCanvas.width - ballType.radius * 2) + ballType.radius,
                y: -ballType.radius,
                vx: (Math.random() - 0.5) * 2,
                vy: ballType.speed,
                radius: ballType.radius,
                type: type,
                health: ballType.health,
                points: ballType.points
            });
        }

        function updateBalls() {
            balls.forEach((ball, index) => {
                // Update position
                ball.x += ball.vx;
                ball.y += ball.vy;
                
                // Bounce off walls
                if (ball.x - ball.radius < 0 || ball.x + ball.radius > shooterCanvas.width) {
                    ball.vx *= -1;
                    ball.x = Math.max(ball.radius, Math.min(shooterCanvas.width - ball.radius, ball.x));
                }
                
                // Check if ball reached bottom (for survival mode)
                if (ball.y - ball.radius > shooterCanvas.height) {
                    balls.splice(index, 1);
                    if (shooterMode === 'survival') {
                        ballsMissed++;
                        if (ballsMissed >= MAX_MISSED_BALLS) {
                            shooterGameOver();
                        }
                    }
                }
            });
        }

        function handleShoot(event) {
            if (shooterGameState !== 'playing') return;
            
            const rect = shooterCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            shootAt(x, y);
        }

        function handleTouchShoot(event) {
            if (shooterGameState !== 'playing') return;
            
            event.preventDefault();
            const rect = shooterCanvas.getBoundingClientRect();
            const touch = event.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            shootAt(x, y);
        }

        function shootAt(x, y) {
            playSound('shoot');
            
            let hitSomething = false;
            const explosionRadius = isPowerShotActive ? 100 : 50;
            
            // Check collision with balls
            balls.forEach((ball, index) => {
                const dx = x - ball.x;
                const dy = y - ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < ball.radius + (isPowerShotActive ? explosionRadius : 10)) {
                    // Hit the ball
                    ball.health--;
                    
                    if (ball.health <= 0) {
                        // Destroy ball
                        ballsDestroyed++;
                        shooterScore += ball.points;
                        
                        // Red balls explode and damage nearby balls
                        if (ball.type === 0) {
                            playSound('explosion');
                            drawExplosion(ball.x, ball.y, ball.radius);
                            
                            // Damage nearby balls
                            balls.forEach((otherBall, otherIndex) => {
                                if (otherIndex !== index) {
                                    const dx2 = ball.x - otherBall.x;
                                    const dy2 = ball.y - otherBall.y;
                                    const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                    
                                    if (distance2 < 100) {
                                        otherBall.health--;
                                        if (otherBall.health <= 0) {
                                            ballsDestroyed++;
                                            shooterScore += otherBall.points;
                                            balls.splice(otherIndex, 1);
                                        }
                                    }
                                }
                            });
                        }
                        
                        balls.splice(index, 1);
                        
                        // Add to power level
                        powerLevel = Math.min(MAX_POWER, powerLevel + 5);
                        if (powerLevel >= MAX_POWER && !isPowerShotActive) {
                            activatePowerShot();
                        }
                        
                        hitSomething = true;
                    }
                }
            });
            
            // Visual feedback for shot
            if (hitSomething) {
                drawExplosion(x, y, 10);
            }
            
            updateShooterDisplay();
        }

        function activatePowerShot() {
            isPowerShotActive = true;
            powerShotTimer = POWER_SHOT_DURATION;
            powerLevel = 0;
            playSound('powerup');
        }

        function updatePowerShot() {
            if (isPowerShotActive) {
                powerShotTimer--;
                if (powerShotTimer <= 0) {
                    isPowerShotActive = false;
                }
                document.getElementById('powerupFill').style.width = '100%';
            } else {
                document.getElementById('powerupFill').style.width = (powerLevel / MAX_POWER * 100) + '%';
            }
        }

        function updateShooterDisplay() {
            document.getElementById('shooterScore').textContent = shooterScore;
            document.getElementById('ballsDestroyed').textContent = ballsDestroyed;
            document.getElementById('finalShooterHighScore').textContent = shooterHighScore;
            
            const value = document.getElementById('modeSpecificValue');
            switch(shooterMode) {
                case 'classic':
                    value.textContent = Math.floor(gameTime) + 's';
                    break;
                case 'survival':
                    value.textContent = ballsMissed + '/' + MAX_MISSED_BALLS;
                    break;
                case 'timeattack':
                    value.textContent = Math.ceil(gameTime) + 's';
                    break;
            }
        }

        function shooterGameLoop() {
            if (shooterGameState !== 'playing') return;
            
            // Clear canvas
            shooterCtx.clearRect(0, 0, shooterCanvas.width, shooterCanvas.height);
            
            // Draw background
            const gradient = shooterCtx.createLinearGradient(0, 0, 0, shooterCanvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            shooterCtx.fillStyle = gradient;
            shooterCtx.fillRect(0, 0, shooterCanvas.width, shooterCanvas.height);
            
            // Spawn balls
            if (Math.random() < 0.03) { // 3% chance per frame
                spawnBall();
            }
            
            // Update game elements
            updateBalls();
            updatePowerShot();
            
            // Update game time
            if (shooterMode === 'timeattack') {
                gameTime -= 1/60; // Assuming 60fps
                if (gameTime <= 0) {
                    shooterGameOver();
                    return;
                }
            } else if (shooterMode === 'classic') {
                gameTime += 1/60;
            }
            
            // Draw game elements
            balls.forEach(ball => {
                drawBall(ball.x, ball.y, ballTypes[ball.type]);
            });
            
            drawParticles();
            
            // Draw power shot indicator
            if (isPowerShotActive) {
                shooterCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                shooterCtx.fillRect(0, 0, shooterCanvas.width, shooterCanvas.height);
                
                shooterCtx.fillStyle = '#ffff00';
                shooterCtx.font = 'bold 30px Comic Sans MS';
                shooterCtx.textAlign = 'center';
                shooterCtx.fillText('POWER SHOT ACTIVE!', shooterCanvas.width/2, 40);
            }
            
            updateShooterDisplay();
            requestAnimationFrame(shooterGameLoop);
        }

        function startShooterGame() {
            shooterGameState = 'playing';
            document.getElementById('shooterPlayBtn').style.display = 'none';
            document.getElementById('shooterPauseBtn').style.display = 'inline-block';
            document.getElementById('shooterGameOverScreen').style.display = 'none';
            
            shooterScore = 0;
            ballsDestroyed = 0;
            powerLevel = 0;
            isPowerShotActive = false;
            balls = [];
            explosions = [];
            particles = [];
            ballsMissed = 0;
            gameTime = shooterMode === 'timeattack' ? 60 : 0;
            
            shooterGameLoop();
        }

        function toggleShooterPause() {
            if (shooterGameState === 'playing') {
                shooterGameState = 'paused';
                document.getElementById('shooterPauseBtn').textContent = '‚ñ∂Ô∏è RESUME';
            } else if (shooterGameState === 'paused') {
                shooterGameState = 'playing';
                document.getElementById('shooterPauseBtn').textContent = '‚è∏Ô∏è PAUSE';
                shooterGameLoop();
            }
        }

        function restartShooterGame() {
            if (shooterGameState === 'gameOver') {
                shooterGameState = 'ready';
            }
            startShooterGame();
        }

        function shooterGameOver() {
            shooterGameState = 'gameOver';
            
            if (shooterScore > shooterHighScore) {
                shooterHighScore = shooterScore;
                localStorage.setItem('ballBlasterHighScore', shooterHighScore);
            }
            
            document.getElementById('finalBallsDestroyed').textContent = ballsDestroyed;
            document.getElementById('finalShooterScore').textContent = shooterScore;
            document.getElementById('finalShooterHighScore').textContent = shooterHighScore;
            
            // Set game over title based on mode
            const title = document.getElementById('shooterGameOverTitle');
            if (shooterMode === 'survival' && ballsMissed >= MAX_MISSED_BALLS) {
                title.textContent = 'GAME OVER - TOO MANY MISSED!';
            } else if (shooterMode === 'timeattack' && gameTime <= 0) {
                title.textContent = 'TIME\'S UP!';
            } else {
                title.textContent = 'GAME OVER!';
            }
            
            document.getElementById('shooterGameOverScreen').style.display = 'block';
            document.getElementById('shooterPlayBtn').style.display = 'inline-block';
            document.getElementById('shooterPauseBtn').style.display = 'none';
            
            playSound('gameOver');
        }

        // ===== WORD MATCH GAME =====
        let wordGameState = 'ready';
        let wordScore = 0;
        let matchedPairs = 0;
        let totalPairs = 5;
        let wordGameTime = 60;
        let wordGameTimer = null;
        let currentWord = '';
        let currentCategory = 'general';
        let selectedCell = null;
        let hintsRemaining = 3;
        let wordHighScore = localStorage.getItem('wordMatchHighScore') || 0;

        // Word database by category
        const wordDatabase = {
            general: [
                { word: "COMPUTER", meaning: "Electronic device for processing data" },
                { word: "ELEPHANT", meaning: "Large mammal with trunk and tusks" },
                { word: "PYRAMID", meaning: "Ancient triangular structure in Egypt" },
                { word: "BUTTERFLY", meaning: "Insect with colorful wings" },
                { word: "TELEVISION", meaning: "Device for watching shows and movies" },
                { word: "BICYCLE", meaning: "Two-wheeled vehicle you pedal" },
                { word: "CHOCOLATE", meaning: "Sweet brown treat made from cocoa" },
                { word: "LIBRARY", meaning: "Place with books you can borrow" },
                { word: "VOLCANO", meaning: "Mountain that erupts with lava" },
                { word: "TELESCOPE", meaning: "Tool for viewing distant objects" }
            ],
            science: [
                { word: "GRAVITY", meaning: "Force that pulls objects toward Earth" },
                { word: "PHOTOSYNTHESIS", meaning: "Process plants use to make food from sunlight" },
                { word: "ATOM", meaning: "Smallest unit of a chemical element" },
                { word: "DNA", meaning: "Molecule carrying genetic instructions" },
                { word: "ELECTRON", meaning: "Tiny particle with negative charge" },
                { word: "ECOSYSTEM", meaning: "Community of living organisms" },
                { word: "EVOLUTION", meaning: "Process of species changing over time" },
                { word: "MICROSCOPE", meaning: "Instrument for viewing tiny objects" },
                { word: "OXYGEN", meaning: "Gas needed for breathing" },
                { word: "SOLAR SYSTEM", meaning: "Sun and all orbiting planets" }
            ],
            tech: [
                { word: "ALGORITHM", meaning: "Step-by-step problem-solving procedure" },
                { word: "BROWSER", meaning: "Software for accessing the internet" },
                { word: "DATABASE", meaning: "Organized collection of information" },
                { word: "ENCRYPTION", meaning: "Converting data to secret code" },
                { word: "HARDWARE", meaning: "Physical parts of a computer" },
                { word: "KEYBOARD", meaning: "Input device with keys for typing" },
                { word: "NETWORK", meaning: "Connected computers sharing resources" },
                { word: "PROCESSOR", meaning: "Brain of the computer" },
                { word: "SOFTWARE", meaning: "Programs and applications" },
                { word: "WIFI", meaning: "Wireless internet connection" }
            ],
            sports: [
                { word: "GOALPOST", meaning: "Structure where points are scored in soccer" },
                { word: "OLYMPICS", meaning: "International multi-sport event" },
                { word: "REFEREE", meaning: "Official enforcing game rules" },
                { word: "STADIUM", meaning: "Large venue for sports events" },
                { word: "TOUCHDOWN", meaning: "Football scoring play worth 6 points" },
                { word: "TROPHY", meaning: "Award given to winners" },
                { word: "UNIFORM", meaning: "Standard clothing for team members" },
                { word: "VOLLEYBALL", meaning: "Sport where ball is hit over a net" },
                { word: "WHISTLE", meaning: "Device used by referees" },
                { word: "CHAMPION", meaning: "Winner of a competition" }
            ],
            food: [
                { word: "AVOCADO", meaning: "Green fruit with large pit" },
                { word: "BROCCOLI", meaning: "Green vegetable with tree-like shape" },
                { word: "CHOCOLATE", meaning: "Sweet treat made from cocoa beans" },
                { word: "HAMBURGER", meaning: "Patty served in a bun" },
                { word: "LASAGNA", meaning: "Layered pasta dish" },
                { word: "PINEAPPLE", meaning: "Tropical fruit with spiky skin" },
                { word: "PIZZA", meaning: "Round flatbread with toppings" },
                { word: "SANDWICH", meaning: "Food between two slices of bread" },
                { word: "STRAWBERRY", meaning: "Red fruit with seeds on outside" },
                { word: "WATERMELON", meaning: "Large fruit with green rind and red flesh" }
            ]
        };

        function initWordGame() {
            updateWordDisplay();
            generateWordGrid();
        }

        function setWordCategory(category) {
            currentCategory = category;
            
            // Update UI
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            restartWordGame();
        }

        function generateWordGrid() {
            const grid = document.getElementById('wordGrid');
            grid.innerHTML = '';
            
            // Get random words from selected category
            const categoryWords = [...wordDatabase[currentCategory]];
            const selectedWords = [];
            
            // Select 5 random words
            for (let i = 0; i < totalPairs; i++) {
                if (categoryWords.length === 0) break;
                const randomIndex = Math.floor(Math.random() * categoryWords.length);
                selectedWords.push(categoryWords[randomIndex]);
                categoryWords.splice(randomIndex, 1);
            }
            
            // Create array with words and meanings
            let gridItems = [];
            selectedWords.forEach(item => {
                gridItems.push({
                    type: 'word',
                    content: item.word,
                    correctMeaning: item.meaning
                });
                gridItems.push({
                    type: 'meaning',
                    content: item.meaning,
                    correctWord: item.word
                });
            });
            
            // Add some wrong meanings
            while (gridItems.length < 10) {
                const wrongWord = selectedWords[Math.floor(Math.random() * selectedWords.length)];
                const allMeanings = wordDatabase[currentCategory].map(w => w.meaning);
                let wrongMeaning;
                do {
                    wrongMeaning = allMeanings[Math.floor(Math.random() * allMeanings.length)];
                } while (wrongMeaning === wrongWord.meaning);
                
                gridItems.push({
                    type: 'meaning',
                    content: wrongMeaning,
                    correctWord: null // No correct word for wrong meaning
                });
            }
            
            // Shuffle grid items
            gridItems = shuffleArray(gridItems);
            
            // Generate grid cells
            gridItems.forEach((item, index) => {
                const cell = document.createElement('div');
                cell.className = 'word-cell';
                cell.dataset.index = index;
                cell.dataset.type = item.type;
                cell.dataset.content = item.content;
                if (item.type === 'meaning') {
                    cell.dataset.correctWord = item.correctWord || '';
                }
                
                // Format content for display
                if (item.type === 'word') {
                    cell.textContent = item.content;
                } else {
                    // Split long meanings into multiple lines
                    const words = item.content.split(' ');
                    let lines = [];
                    let currentLine = '';
                    
                    words.forEach(word => {
                        if ((currentLine + word).length <= 15) {
                            currentLine += (currentLine ? ' ' : '') + word;
                        } else {
                            lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    if (currentLine) lines.push(currentLine);
                    
                    cell.innerHTML = lines.join('<br>');
                }
                
                cell.onclick = () => selectWordCell(index);
                grid.appendChild(cell);
            });
            
            // Set first word as current
            const words = gridItems.filter(item => item.type === 'word');
            if (words.length > 0) {
                currentWord = words[0].content;
                document.getElementById('currentWordDisplay').textContent = currentWord;
            }
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function selectWordCell(index) {
            if (wordGameState !== 'playing') return;
            
            const cell = document.querySelector(`.word-cell[data-index="${index}"]`);
            const cellType = cell.dataset.type;
            
            if (cell.classList.contains('matched')) return;
            
            if (cellType === 'word') {
                // Selecting a new word
                if (selectedCell) {
                    selectedCell.classList.remove('selected');
                }
                cell.classList.add('selected');
                selectedCell = cell;
                currentWord = cell.dataset.content;
                document.getElementById('currentWordDisplay').textContent = currentWord;
            } else if (cellType === 'meaning') {
                // Selecting a meaning - check if it matches current word
                if (!selectedCell) return;
                
                const correctWord = cell.dataset.correctWord;
                
                if (correctWord === currentWord) {
                    // Correct match!
                    cell.classList.add('matched');
                    selectedCell.classList.add('matched');
                    
                    wordScore += 100;
                    matchedPairs++;
                    
                    playSound('correct');
                    
                    // Clear selection
                    selectedCell.classList.remove('selected');
                    selectedCell = null;
                    
                    // Find next unmatched word
                    const nextWordCell = document.querySelector('.word-cell[data-type="word"]:not(.matched)');
                    if (nextWordCell) {
                        currentWord = nextWordCell.dataset.content;
                        document.getElementById('currentWordDisplay').textContent = currentWord;
                        nextWordCell.classList.add('selected');
                        selectedCell = nextWordCell;
                    } else {
                        // All words matched!
                        endWordGame();
                    }
                } else {
                    // Wrong match
                    wordScore = Math.max(0, wordScore - 20);
                    cell.classList.add('selected');
                    setTimeout(() => {
                        cell.classList.remove('selected');
                    }, 500);
                    playSound('wrong');
                }
                
                updateWordDisplay();
            }
        }

        function useHint() {
            if (hintsRemaining <= 0 || wordGameState !== 'playing') return;
            
            hintsRemaining--;
            
            // Find correct meaning for current word
            const meaningCells = document.querySelectorAll('.word-cell[data-type="meaning"]:not(.matched)');
            let correctCell = null;
            
            meaningCells.forEach(cell => {
                if (cell.dataset.correctWord === currentWord) {
                    correctCell = cell;
                }
            });
            
            if (correctCell) {
                // Highlight the correct cell
                correctCell.style.animation = 'matchPulse 1s infinite';
                document.getElementById('hintText').textContent = "Hint: The correct meaning is highlighted!";
                
                setTimeout(() => {
                    correctCell.style.animation = '';
                    document.getElementById('hintText').textContent = "";
                }, 2000);
            }
            
            document.getElementById('hintBtn').textContent = `GET HINT (${hintsRemaining} LEFT)`;
            if (hintsRemaining <= 0) {
                document.getElementById('hintBtn').disabled = true;
            }
        }

        function startWordGame() {
            wordGameState = 'playing';
            document.getElementById('wordPlayBtn').style.display = 'none';
            document.getElementById('wordPauseBtn').style.display = 'inline-block';
            document.getElementById('wordGameOverScreen').style.display = 'none';
            
            wordScore = 0;
            matchedPairs = 0;
            wordGameTime = 60;
            hintsRemaining = 3;
            selectedCell = null;
            
            // Reset grid
            const cells = document.querySelectorAll('.word-cell');
            cells.forEach(cell => {
                cell.classList.remove('selected', 'matched');
            });
            
            generateWordGrid();
            updateWordDisplay();
            
            // Enable hint button
            document.getElementById('hintBtn').disabled = false;
            document.getElementById('hintBtn').textContent = `GET HINT (${hintsRemaining} LEFT)`;
            document.getElementById('hintText').textContent = "";
            
            // Start timer
            wordGameTimer = setInterval(updateWordTimer, 1000);
        }

        function toggleWordPause() {
            if (wordGameState === 'playing') {
                wordGameState = 'paused';
                document.getElementById('wordPauseBtn').textContent = '‚ñ∂Ô∏è RESUME';
                clearInterval(wordGameTimer);
            } else if (wordGameState === 'paused') {
                wordGameState = 'playing';
                document.getElementById('wordPauseBtn').textContent = '‚è∏Ô∏è PAUSE';
                wordGameTimer = setInterval(updateWordTimer, 1000);
            }
        }

        function updateWordTimer() {
            if (wordGameState !== 'playing') return;
            
            wordGameTime--;
            updateWordDisplay();
            
            if (wordGameTime <= 0) {
                endWordGame();
            }
        }

        function updateWordDisplay() {
            document.getElementById('wordScore').textContent = wordScore;
            document.getElementById('matchedCount').textContent = `${matchedPairs}/${totalPairs}`;
            document.getElementById('wordTime').textContent = `${wordGameTime}s`;
        }

        function endWordGame() {
            wordGameState = 'gameOver';
            clearInterval(wordGameTimer);
            
            // Calculate time bonus
            const timeBonus = Math.max(0, Math.floor(wordGameTime) * 10);
            const totalScore = wordScore + timeBonus;
            
            if (totalScore > wordHighScore) {
                wordHighScore = totalScore;
                localStorage.setItem('wordMatchHighScore', wordHighScore);
            }
            
            document.getElementById('finalWordScore').textContent = totalScore;
            document.getElementById('finalMatched').textContent = `${matchedPairs}/${totalPairs}`;
            document.getElementById('timeBonus').textContent = timeBonus;
            
            document.getElementById('wordGameOverScreen').style.display = 'block';
            document.getElementById('wordPlayBtn').style.display = 'inline-block';
            document.getElementById('wordPauseBtn').style.display = 'none';
            
            playSound('complete');
        }

        function restartWordGame() {
            if (wordGameState === 'gameOver') {
                wordGameState = 'ready';
            }
            startWordGame();
        }

        
    </script>
</body>
</html>